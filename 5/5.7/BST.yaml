사전은 pair<key, value>의 집합:

이원 탐색 트리:
- 정의:
  - 이진 트리로서 공백이 가능하고, 만약 공백이 아니라면
  - 1. 모든 원소는 서로 상이한 키를 갖는다
  - 2. 왼쪽 서브트리의 키들은 그 루트의 키보다 작다
  - 3. 오른쪽 서브트리의 키들은 그 루트의 키보다 크다
  - 4. 왼쪽과 오른쪽 서브트리도 이원 탐색 트리이다
- 과정:
  - k == 루트의 키 : 성공적 종료
  - k < 루트의 키 : 왼쪽 서브트리 탐색
  - k > 루트의 키 : 오른쪽 서브트리 탐색
- 순위에 의한 이원 탐색 트리의 탐색:
  - 순위:
    - 중위 순서에서의 위치
    - leftSize = 왼쪽 서브 트리의 원소 수 + 1
- 삽입:
  - x의 key값을 가진 노드를 탐색. 
    - 탐색 성공 시, 키에 연관된 원소를 변경한다.
    - 탐색 실패 시, 탐색이 끝난 지점에 쌍을 삽입.
- 삭제:
  - leaf 원소의 삭제
    - 부모의 자식 필드에 0을 삽입하고 삭제된 노드를 반환
  - non-leaf 노드 삭제
    - 삭제된 노드의 자식을 삭제된 노드의 자리에 위치
    - 자식 노드가 두 개라면?
      - 왼쪽 서브트리에서 가장 큰 원소나 오른쪽 서브트리에서 가장 작은 원소로 대체
      - 대체된 서브트리에서 대체한 원소의 삭제 과정 진행(서브트리의 루트 노드 삭제)
  - 시간 복잡도 = O(h)
- join:
  - ThreeWayJoin(small, mid, big)
    - 이원 탐색 트리 small과 big에 있는 쌍들과 쌍 mid로 구성되는 이원 탐색 트리를 생성
      - 서브트리 두 개를 하나의 트리로 합침
    - 새로운 노드를 하나 얻어서
      - data = mid
      - leftChild = small.root
      - rightChild = big.root
    - O(1)
  - TwoWayJoin(small, big)
    - 이원 탐색 트리 small, big에 있는 모든 쌍들을 포함하는 하나의 이원 탐색 트리를 생성
      - small or big = 0
        - 공백이 아닌 것이 트리
      - 둘 다 공백이 아닐 때
        - small에서 가장 큰 키 값을 가진 mid 쌍 삭제 = small'
        - ThreeWayJoin(small', mid, big) 수행
    - O(height(small))
- Split(k, small, mid, big):
  - 이원 탐색 트리 *this를 세 부분으로 분할
  - small은 *this의 원소 중 키 값이 k보다 작은 모든 쌍 포함
    - k < root.data->first
      - big이 루트, 오른쪽 서브트리 포함
  - mid는 *this의 원소 중 키 값이 k와 같은 쌍을 포함
    - k = root->data.first
  - big은 *this의 원소 중 키 값이 k보다 큰 모든 쌍을 포함
    - k > root.data->first
      - small이 루트, 왼쪽 서브트리 포함
- 이원 탐색 트리의 높이: 
  - 이원 탐색 트리의 원소 수가 n일 때
    - 최악의 경우 트리의 높이가 n, 키[1,2,3...n]을 순서대로 삽입
    - 평균 이원 탐색 트리의 높이 O(logn)
  - 균형 탐색 트리
    - 최악의 경우에도 height = O(logn)이 되는 트리
    - 탐색, 삽입, 삭제의 시간 복잡도가 O(h)
    - AVL, 2-3, 2-3-4, 레드-블랙(red-black), B 트리, B+ 트리 등