시간 복잡도:
- 프로그램을 완전히 실행시키는데 필요한 시간
- T(P) = 컴파일 시간 + 실행시간(t_p(인스턴스 특성))
- t_p(n)=c_aADD(n)+c_sSUB(n)+c_mMUL(n)+c_dDIV(n)+ ...
  n:인스턴스 특성
  c:연산을 위한 상수 시간
  ADD...: n번 연산하는 상수 시간

프로그램 단계 수(number of steps):
- 주석 : 0
- 선언문 : 0
  변수, 상수 정의(int,long...)
  사용자 데이타 타입 정의(class, struct...)
  접근 결정(private, public, protected, friend)
  함수 타입 결정(void, virtual)
- 산술식 및 지정문 : 1
  예외: 함수 호출을 포함하는 산술
- 반복문: 제어 부분에 대해서만 단계 수 고려
- 스위치 명령문:
  switch(<expr>)의 비용 = <expr>의 비용
  각 조건의 비용 = 자기의 비용 + 앞서 나온 모든 조건의 비용
- if-else 문:
  <expr>, <statement1>, <statement2> 에 따라 각각 단계 수 할당
- 함수 호출:
  값에 의한 전달 인자 포함하지 않을 경우: 1
  값에 의한 전달 인자 포함할 경우: 값 인자 크기의 합
  순환적인 경우: 호출되는 함수의 지역 변수도 고려
- 메모리 관리 명령문: 1
- 함수 명령문: 1
  비용이 이미 호출문에 할당
- 분기 명령문: 1

단계 수 테이블:
- 명령문의 실행 당 단계 수 결정
  s/e: 그 명령문의 실행 결과로 count가 변화하는 양
- 명령문이 실행되는 총 횟수 계산

line float Sum(float *a, const int n)
{ 
  float s=0;    //선언문이자 할당문
  for(int i=0;i<n;i++)    //제어문
    s+=a[i];
  return s;
}

행 번호  s/e   빈도   단계수
  1      0      1      0
  2      1      1      1
  3      1      n+1    n+1
  4      1      n      n
  5      1      1      1
  6      0      1      0
  총 단계 수 = 2n+3
